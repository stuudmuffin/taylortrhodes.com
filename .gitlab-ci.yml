image: docker:28.3.3

variables:
    SSH_PRIVATE_KEY: ${SSH_PRIVATE_KEY}
    DOCKER_REGISTRY: $CI_REGISTRY/$CI_PROJECT_PATH
    CONTAINER_BRANCH_IMAGE: $DOCKER_REGISTRY:latest
    LOCAL_BUILD_PATH: "src/"

stages:
    - build
    - deploy
    - deploy_s3

Build Image:
  stage: build
  rules:
    - changes: # run automatically if any of these change
        - src/**/*
        - Dockerfile
        - Caddyfile
        - .gitlab-ci.yml
    - when: manual 
  services:
    - docker:28.3.3-dind
  before_script:
    - echo $CI_REGISTRY
    - echo $CI_PROJECT_PATH
    - echo $DOCKER_REGISTRY
    - echo $CONTAINER_BRANCH_IMAGE
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "BUILD_REF=$CI_COMMIT_REF_NAME" > src/buildinfo.txt
    - echo "BUILD_SHA=$CI_COMMIT_SHORT_SHA" >> src/buildinfo.txt
    - echo "BUILD_TAG=$CI_COMMIT_TAG" >> src/buildinfo.txt
    - docker build --network host -t $CONTAINER_BRANCH_IMAGE .
    - docker push $CONTAINER_BRANCH_IMAGE
    #- docker system prune -af --filter "until=$((30*24))h"
  artifacts:
    paths:
    - src

Deploy Dev Instance:
  stage: deploy
  image: alpine:3.22
  environment: 
    name: dev
    url: https://dev.taylortrhodes.com
  tags:
    - homelab
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: true
    - if: '$CI_COMMIT_BRANCH =~ /^hotfix\//'
      when: on_success
    - when: never
  variables:
    SSH_PORT: "22"
    TARGET_HOST: $SSH_IP
    SSH_USER: "taylor"
  before_script:
    - |
      set -euo pipefail
      apk add --no-cache openssh-client bash file
  script:
    - chmod 600 "$SSH_KEY"
    - ssh-keygen -lf "$SSH_KEY" || true
    - |
      ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$SSH_USER@$TARGET_HOST" "CI_REGISTRY=$CI_REGISTRY CI_REGISTRY_USER=$CI_REGISTRY_USER CI_REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD CONTAINER_BRANCH_IMAGE=$CONTAINER_BRANCH_IMAGE bash -s" <<'EOSSH'
      set -euo pipefail
  
      # sanity checks
      echo checking varaibles
      : "${CI_REGISTRY:?missing}"
      : "${CI_REGISTRY_USER:?missing}"
      : "${CI_REGISTRY_PASSWORD:?missing}"
      : "${CONTAINER_BRANCH_IMAGE:?missing}"
  
      # login to GitLab Container Registry (NOT Docker Hub)
      echo logging in to gitlab docker registry
      echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  
      # pull first; only stop/replace on successful pull
      echo pull image from registry
      docker pull "$CONTAINER_BRANCH_IMAGE"
  
      echo stopping and removing old container
      docker stop dev.taylortrhodes.com 2>/dev/null || true
      docker rm   dev.taylortrhodes.com 2>/dev/null || true
  
      # NOTE: adjust right side of -p if your container listens on 80 vs 8080
      echo starting new container
      docker run --name dev.taylortrhodes.com -p 8084:8080 --restart=always -d "$CONTAINER_BRANCH_IMAGE"
      EOSSH
  timeout: 5 minutes

Deploy DO VM:
  stage: deploy
  image: alpine:3.22
  environment:
    name: prod
    url: https://www.taylortrhodes.com
  tags:
    - homelab
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH =~ /^hotfix\//'
      when: manual
    - when: never
  variables:
    DO_API: "https://api.digitalocean.com/v2"
    SSH_PORT: "22"
    TARGET_HOST: $DO_VM_IP
    SSH_USER: "root"
  before_script:
    - |
      set -euo pipefail
      apk add --no-cache openssh-client bash
  #    apk add --no-cache openssh-client curl bash busybox-extras jq
  #    # discover this job's egress IP
  #    JOB_IP="$(curl -fsS https://checkip.amazonaws.com | tr -d '\n')"
  #    echo "Job egress IP: $JOB_IP"
  #    echo "$JOB_IP" > .allowlisted_ip
#
  #    # allow SSH from this job's /32
  #    ADD_PAYLOAD='{"inbound_rules":[{"protocol":"tcp","ports":"'"$SSH_PORT"'","sources":{"addresses":["'"$JOB_IP"'/32"]}}]}'
  #    ADD_CODE=$(curl -sS -o /tmp/do_add.json -w "%{http_code}" \
  #      -X POST "$DO_API/firewalls/$DO_FIREWALL_ID/rules" \
  #      -H "Authorization: Bearer $DO_TOKEN" \
  #      -H "Content-Type: application/json" \
  #      --data "$ADD_PAYLOAD")
  #    echo "DO add status: $ADD_CODE"
  #    if [ "$ADD_CODE" != "204" ] && [ "$ADD_CODE" != "200" ]; then
  #      cat /tmp/do_add.json
  #      exit 1
  #    fi
  script:
    - chmod 600 "$SSH_KEY"
    - ssh-keygen -lf "$SSH_KEY" || true
    - |
      ssh -i "$SSH_KEY" -o StrictHostKeyChecking=no "$SSH_USER@$TARGET_HOST" "CI_REGISTRY=$CI_REGISTRY CI_REGISTRY_USER=$CI_REGISTRY_USER CI_REGISTRY_PASSWORD=$CI_REGISTRY_PASSWORD CONTAINER_BRANCH_IMAGE=$CONTAINER_BRANCH_IMAGE bash -s" <<'EOSSH'
      set -euo pipefail
  
      # sanity checks
      echo checking varaibles
      : "${CI_REGISTRY:?missing}"
      : "${CI_REGISTRY_USER:?missing}"
      : "${CI_REGISTRY_PASSWORD:?missing}"
      : "${CONTAINER_BRANCH_IMAGE:?missing}"
  
      # login to GitLab Container Registry (NOT Docker Hub)
      echo logging in to gitlab docker registry
      echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  
      # pull first; only stop/replace on successful pull
      echo pull image from registry
      docker pull "$CONTAINER_BRANCH_IMAGE"
  
      echo stopping and removing old container
      docker stop taylortrhodes.com 2>/dev/null || true
      docker rm   taylortrhodes.com 2>/dev/null || true
  
      # NOTE: adjust right side of -p if your container listens on 80 vs 8080
      echo starting new container
      docker run --name taylortrhodes.com -p 8085:8080 --restart=always -d "$CONTAINER_BRANCH_IMAGE"
      EOSSH
  #after_script:
  #  - |
  #    # remove the allow rule (idempotent)
  #    echo cleaning up run environment
  #    if [ -f .allowlisted_ip ]; then
  #      JOB_IP="$(cat .allowlisted_ip)"
  #      DEL_PAYLOAD='{"inbound_rules":[{"protocol":"tcp","ports":"'"$SSH_PORT"'","sources":{"addresses":["'"$JOB_IP"'/32"]}}]}'
  #      DEL_CODE=$(curl -sS -o /dev/null -w "%{http_code}" \
  #        -X DELETE "$DO_API/firewalls/$DO_FIREWALL_ID/rules" \
  #        -H "Authorization: Bearer $DO_TOKEN" \
  #        -H "Content-Type: application/json" \
  #        --data "$DEL_PAYLOAD")
  #      echo "DO delete status: $DEL_CODE"
  #    fi
  timeout: 5 minutes

#Deploy S3:
#  stage: deploy_s3
#  image:
#    name: amazon/aws-cli:2.17.19
#    entrypoint: [""]
#  needs: []
#  when: always
#  variables:
#    AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
#    AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
#    AWS_REGION: $AWS_REGION
#  script:
#    - |
#      set -euo pipefail
#
#      # Sync HTML with no-cache for instant updates
#      aws s3 sync src/ "s3://$S3_BUCKET/" \
#        --exclude "assets/*" --delete \
#        --cache-control "no-cache" --exact-timestamps --no-progress
#
#      # Sync versioned/static assets with long cache
#      aws s3 sync src/assets/ "s3://$S3_BUCKET/assets/" \
#        --delete \
#        --cache-control "public,max-age=31536000,immutable" \
#        --exact-timestamps --no-progress
